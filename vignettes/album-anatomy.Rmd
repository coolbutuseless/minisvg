---
title: "Patterns from Album Anatomy by Duane Dalton"
author: "Dmytro Perepolkin"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{AlbumAnatomy}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>"
)
```

## Introduction

These examples are attempting to reproduce some of the patterns used in [Album Anatomy series of posters produced by Duane Dalton](https://duanedalton.com/). Not only are these patterns extremely well designed, they are also useful to illustrate important concepts in use of various `stags` in `minisvg`, as well as application of transformations, filters and masks.

```{r setup}
library(minisvg)
```

## Hurts 4802

This example is reproducing "Hurts 4802" poster from ["Album Anatomy" poster collection](https://www.behance.net/gallery/2770133/Album-Anatomy). 

* The main design element defined in a separate group and included in defs to be reused in mask
and in design itself.
* Transform is happening at the reuse of the graphical element. Use tag does not pull in original element, so it can be independently modified by the transform.


```{r comment=''}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the document with white background and a main design element as a "loose" group
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
doc <- svg_doc(width=300, height = 400,
               stag$rect(width = '100%', height = '100%', fill="white",stroke="grey50", stroke_width=1))

stripeg <- stag$g(id="stripe",  
  stag$circle(cx=225, cy=150, r=75),
  stag$rect(x=225-75, y=150, width=151, height  = 400-133 )
)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Reuse the same element inside mask, specifying fill and transform
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stripeg_mask <- stag$mask(id="stripe_mask", height = 400, width = 150,
                          stag$g(
                            stag$rect(x='0%',y='0%',width = '50%', height = '100%', fill="white"),
                            stag$use(`xlink:href`="#stripe", fill="black", 
                                     svg_prop$transform$rotate(180, 150, 200))
                          )
                      )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Put both element and a mask into defs. Use element and the mask
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
doc$add('defs', stripeg_mask, stripeg)
doc$use(`xlink:href`="#stripe", fill="grey30")
doc$rect(x=0,y=0, width='100%', height = '100%', mask=stripeg_mask, fill="grey30")  
```


<!-- Raw HTML output. hidden by default -->
<details closed>
<summary> <span title='Raw HTML'> Raw SVG Text (click to open) </span> </summary>
```{r echo = FALSE, comment=""}
print(doc)
```
</details><br />


```{r echo = FALSE}
doc
```



## Bon Iver 3925

This example is reproducing "Bon Iver 3925" poster from ["Album Anatomy" poster collection](https://bldgwlf.com/album-anatomy-2/)

* The main shape (triangle) is defined only once. It is later reused (scaled and shifted), both original and the transformed triangles are grouped and reused again (with a different fill) to complete a pattern. This is done with `use` and `xlink:href`.
* Even though it would be possible to just overlay a circle colored in background color,
in this example, `mask` is used to demonstrate compositing objects. Black objects will become holes and white objects will become opaque areas.
* Even though it would be possible to achieve somewhat similar results by manipulating
transparency of the objects, this example demonstrates the use of `feBlend` to combine
opaque objects. Multiplication of brown triangle with the pattern produces color combination
very close to original artwork by Duane Dalton.

```{r comment=''}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the size of canvas and main design element: the triangle
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
w <- 540; h <- 480
big_trg <- stag$polygon(id="big_3angl", xs = c(0,0,w/9,0), ys = c(0,h/4,h/4,0))

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define BW mask that will be used to punch a hole in a big triangle
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
holeMask <- stag$mask(id="myMask",
                  stag$rect(x=0,y=0, width="100%", height = "100%", fill="white"),
                  stag$circle(cx=w/9/3, cy=w/4-w/15, r=9, fill='black'))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define pattern group: big triangle (punched) and small triangle (shifted and scaled)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
trgs <- stag$g(id='triangles', stroke = 'none',
               stag$use(`xlink:href` = "#big_3angl", mask="url(#myMask)"),
               stag$use(`xlink:href` = "#big_3angl", 
                        transform=glue::glue("translate({w/9/2}) scale(0.5 0.5)")))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define pattern: it uses pattern group twice (original and shifted) with different fill
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pat <- stag$pattern(width=w/9*2, height=h/4, id = 'motif', patternUnits = 'userSpaceOnUse')

pat$use(`xlink:href` = "#triangles", fill="#007360")
pat$use(`xlink:href` = "#triangles", fill="#a1d1b9", svg_prop$transform$translate(w/9))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define filter for overlaying pattern over brown triangle in "multiply" mode
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mutiFilter <- stag$filter(id="multiplyMe", stag$feBlend(mode="multiply",
                          in_="SourceGraphic", in2 = "BackgroundImage"))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define document with white-ish background and add all above objects to "defs"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
doc <- svg_doc(width = w, height = h,
               stag$rect(x=0, y=0, width='100%', height='100%', fill='#faf6f2'))

doc$add('defs', holeMask, big_trg, trgs, pat, mutiFilter)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define brown triangle and overlay it with a pattern multiplying these layers
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
doc$add('polygon', xs=c(0, w/9*2,0,0), ys=c(0, h/2, h, 0), fill="#c55b48", fill_opacity=1)
doc$add('rect', x=0, y=0, width='100%', height='100%', fill=pat, filter="url(#multiplyMe)")
```


<!-- Raw HTML output. hidden by default -->
<details closed>
<summary> <span title='Raw HTML'> Raw SVG Text (click to open) </span> </summary>
```{r echo = FALSE, comment=""}
print(doc)
```
</details><br />


```{r echo = FALSE}
doc$save("svg/boniver3925.svg")
rsvg::rsvg_png("svg/boniver3925.svg", "images/boniver3925.png")
knitr::include_graphics("images/boniver3925.png")
```

Please, note that `feBlend` may not be properly rendered by [your browser](https://stackoverflow.com/questions/4797803/svg-feblend-in-pattern) (that is the case when all pattern triangles look the same dark color). Try convering `svg` image to `png` using `rsvg::rsvg_png()` or rendering it in Chrome.

## Palma Violets 4218

This example is reproducing "Palma Violets 4218" poster from ["Album Anatomy" poster collection](https://www.behance.net/gallery/2770133/Album-Anatomy)

* This pattern consists of a quarter circle segment, which can be achieved by drawing full circle and clipping it to size
* Row 3 contains "inverted pattern". This can be achieved by reusing the pattern as a mask and
"cutting" plain square with it. Note that we store away custom made cell ("negCrescent")
* Identifying the repeating pattern in the rows, we then compose a pattern in the first column
and apply it across

```{r comment=''}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the size of cell and clip path of this size to contain each cell element
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
s <- 100;
clipsq <- stag$clipPath(id="clipSquare",
                        stag$rect(x=0, y=0, width = s, height = s))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the main geometry: a circle clipped to cell size by `clip-path`
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
g <- stag$circle(id="crescent", cx=s, cy=s, r=s, fill="#faf6f2", `clip-path`="url(#clipSquare)")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# define a mask for "inverted" cell in row 3. Deep copy circle and update its fill
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
gmsk <- stag$mask(id="crescentMask",
                  stag$rect(x=0, y=0, width = '100%', height ='100%', fill="white"),
                  g$copy()$update(fill="black"))#, svg_prop$transform$rotate(180, s/2,s/2)))

ig <- stag$rect(id="negCrescent", x=0, y=0, width='100%', height='100%', fill="#faf6f2", 
                mask="url(#crescentMask)", `clip-path`="url(#clipSquare)")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Compose a pattern as a single column. Translate and rotate main cell as needed
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pat <- stag$pattern(width=s, height=s*5, id = 'motif', patternUnits = 'userSpaceOnUse')
pat$use(`xlink:href`="#crescent")
pat$use(`xlink:href`="#crescent", 
        transform=glue::glue("translate(0 {s*1}) rotate(90 {s/2} {s/2})"))
pat$use(`xlink:href`="#negCrescent",
        transform=glue::glue("translate(0 {s*2}) rotate(180 {s/2} {s/2})"))
        #svg_prop$transform$translate(0, s*2))
pat$use(`xlink:href`="#crescent", 
        transform=glue::glue("translate(0 {s*3}) rotate(90 {s/2} {s/2})"))
pat$use(`xlink:href`="#crescent", 
        transform=glue::glue("translate(0 {s*4}) rotate(-90 {s/2} {s/2})"))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the document, add all above elements to `defs` and roll out the pattern
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
doc <- svg_doc(width = s*5, height = s*5, 
               stag$rect(x=0, y=0, width='100%', height='100%', fill="grey20"))
doc$add('defs', clipsq, g, ig, gmsk, pat)
doc$add('rect', x=0, y=0, width='100%', height='100%', fill=pat)

```





<!-- Raw HTML output. hidden by default -->
<details closed>
<summary> <span title='Raw HTML'> Raw SVG Text (click to open) </span> </summary>
```{r echo = FALSE, comment=""}
print(doc)
```
</details><br />


```{r echo = FALSE}
doc
#doc$save("svg/palmaviolets4218.svg")
#rsvg::rsvg_png("svg/palmaviolets4218.svg", "images/palmaviolets4218.svg")
#knitr::include_graphics("images/palmaviolets4218.svg")
```

## Crystal Castles 5155


This example is reproducing "Crystal Castles 5155" poster from ["Album Anatomy" poster collection](https://www.behance.net/gallery/2770133/Album-Anatomy)

* This pattern consists of a hex (6 triangles), two half-hexes below it and small wedges
above the main hex to cover the fact that pattern can only be rectangular.
* Same constructed hex elements are then reused to create a mask - top few hexes are "hidden"
under it to create the narrow tower head. Also note that mask elements are created in the list
and dumped into the group to be transposed where they need to go. It is a good idea to leave 
transformations to the group and not define them on the children. Then same children can be 
reused in several places, wrapped into custom groups.
* Same hexagon is then reused third time to create a window.
* There's a trick how to create a pattern which starts from the corner of the object, not from point 0,0 of the screen. Read more about coordinate system and transformations [here](http://tavmjong.free.fr/SVG/publish/coords.html).

```{r comment=''}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define service functions for updating children lists and calculate hex vertices
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
update_children <- function(obj, ...){
  obj$update_child_list(
    lapply(obj$children, function(x) x$update(...)))
}

len     <- 40
shift0 <- function(x) x - min(x)
get_hex_coords <- function(len, f, angles) shift0(round(len * f(angles) + len, 2))

angles <- (seq(0, 360, 60) + 90) * pi/180
xs    <- get_hex_coords(len, cos, angles)
ys    <- get_hex_coords(len, sin, angles)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define color to be used in the pattern. Cache dimensions of hex and centroids
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
colrs <- c( "#906a83", "#a68796","#754a68", "#a68796","#c5b2b8", "#7c5570")

min_xs <- min(xs); max_xs <- max(xs)
min_ys <- min(ys); max_ys <-max(ys)
xsC <- c(min_xs, mean(range(xs)), max_xs)
ysC <- c(max_ys+len/2, mean(range(ys)), max_ys+len/2)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define pattern. Note pattern units - pattern starts from 0 and spreads indefinitely.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pat  <- stag$pattern(width=max_xs, height=max_ys+len, #this means 3x4.5 patterns
                     id = 'motif', 
                     patternContentUnits = "userSpaceOnUse",
                     patternUnits="userSpaceOnUse")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This loop creates a hex. Adds to the group created for storing whole hex
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
g_hex <-  stag$g(id="hex")
for (i in head(seq_along(xs), -1)){
  g_hex$polygon(xs=c(xsC[2], xs[i], xs[i+1], xsC[2]),
            ys=c(ysC[2], ys[i], ys[i+1], ysC[2]), fill=colrs[i], 
            stroke="none")
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define half-hex for right- and left side and small upper segments. Add all to pattern
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
g_ohex_right <- stag$g(id="ohex_right")
g_ohex_uright <- stag$g(id="ohex_uright")
# lower and upper right pennants (segment 1 split)
g_ohex_right$polygon(xs=c(max_xs,xsC[2],max_xs, max_xs),
               ys=c(max_ys+len, max_ys+len, ysC[3], max_ys+len), fill=colrs[1])
g_ohex_uright$polygon(xs=c(max_xs,xsC[2],max_xs, max_xs),
               ys=c(min_ys+len/2, min_ys, min_ys, min_ys+len/2), fill=colrs[1])
# segments 2 and 3 on the right
g_ohex_right$polygon(xs=c(max_xs,xsC[2],xsC[2], max_xs),
               ys=c(ysC[3], max_ys+len, max_ys, ysC[3]), fill=colrs[2])
g_ohex_right$polygon(xs=c(max_xs,xsC[2],max_xs, max_xs),
               ys=c(ysC[3], max_ys, max_ys-len/2, ysC[3]), fill=colrs[3])

g_ohex_left <- stag$g(id="ohex_left")
g_ohex_uleft <- stag$g(id="ohex_uleft")
## lower and upper left pennants (segment 6 split)
g_ohex_left$polygon(xs=c(min_xs,xsC[2],min_xs, min_xs),
               ys=c(max_ys+len, max_ys+len, ysC[1], max_ys+len), fill=colrs[6])
g_ohex_uleft$polygon(xs=c(min_xs,xsC[2],min_xs, min_xs),
               ys=c(min_ys+len/2, min_ys, min_ys, min_ys+len/2), fill=colrs[6])
# segments 5 and 4 on the right
g_ohex_left$polygon(xs=c(min_xs,xsC[2],xsC[2], min_xs),
               ys=c(ysC[1], max_ys+len, max_ys, ysC[1]), fill=colrs[5])
g_ohex_left$polygon(xs=c(min_xs,xsC[2],min_xs, min_xs),
               ys=c(ysC[1], max_ys, max_ys-len/2, ysC[1]), fill=colrs[4])

pat$append(g_hex, g_ohex_right, g_ohex_uright, g_ohex_left, g_ohex_uleft)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Copy hexes. These will become masks.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
g1_hex <- update_children(g_hex$copy(), fill="black", stroke="black")$update(id="hex1")
g1_ohex_right <- update_children(g_ohex_right$copy(),  fill="black", stroke="black")$update(id="ohex1_right")
g1_ohex_uright <- update_children(g_ohex_uright$copy(),  fill="black", stroke="black")$update(id="ohex1_uright")
g1_ohex_left <- update_children(g_ohex_left$copy(),  fill="black", stroke="black")$update(id="ohex1_left")
g1_ohex_uleft <- update_children(g_ohex_uleft$copy(),  fill="black", stroke="black")$update(id="ohex1_uleft")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define a list that will store mask elements for covering the tops of "towers".
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mask_lst <- list(
  stag$rect(x='0%', y='0%', width = '100%', height = '100%', fill="white"),
  stag$g(svg_prop$transform$translate(0, 0),
         stag$use(`xlink:href`="#hex1"),
         stag$use(`xlink:href`="#ohex1_uleft"),
         stag$use(`xlink:href`="#ohex1_left"),
         stag$use(`xlink:href`="#ohex1_uright")
  ),
  stag$g(svg_prop$transform$translate(max_xs, 0),
         stag$use(`xlink:href`="#ohex1_uleft"),
         stag$use(`xlink:href`="#ohex1_uright")
  ),
  stag$g(svg_prop$transform$translate(2*max_xs, 0),
         stag$use(`xlink:href`="#hex1"),
         stag$use(`xlink:href`="#ohex1_uleft"),
         stag$use(`xlink:href`="#ohex1_right"),
         stag$use(`xlink:href`="#ohex1_uright")
  ),
  stag$g(svg_prop$transform$translate(0, max_ys+len), 
         stag$use(`xlink:href`="#ohex1_uleft")
  ),
  stag$g(svg_prop$transform$translate(0+2*max_xs, 0+max_ys+len), 
         stag$use(`xlink:href`="#ohex1_uright")
  ))

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define a first mask. Not that mask is wrapped into translated group.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
header_mask1_g <- stag$g(svg_prop$transform$translate(35,220))
invisible(sapply(mask_lst, function(x) header_mask1_g$append(x)))

header_mask1 <- stag$mask(id='header_mask1', x='0%', y='0%', width='100%', height='100%', 
                             maskUnits="objectBoundingBox", 
                             maskContentUnits = "userSpaceOnUse",
                             header_mask1_g)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define a second mask. Not that mask is wrapped into translated group.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
header_mask2_g <- stag$g(svg_prop$transform$translate(381,100))
invisible(sapply(mask_lst, function(x) header_mask2_g$append(x)))

header_mask2 <- stag$mask(id='header_mask2', x='0%', y='0%', width='100%', height='100%', #this means 3x4.5 patterns
                          maskUnits="objectBoundingBox", #objectBoundingBox
                          maskContentUnits = "userSpaceOnUse",
                          header_mask2_g)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define a pattern for striped background behind 2 tower
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pat_lines  <- stag$pattern(width=300, height=10, #this means 3x4.5 patterns
                           id = 'motif_lines', 
                           patternContentUnits = "userSpaceOnUse",
                           patternUnits="userSpaceOnUse",
                           stag$g(
                           stag$line(x1 = 0, x2=300, y1=8, y2=8), 
                                stroke="#754a68", stroke_width=2))

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Copy the hex to be used as "white window" on towers.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
g2_hex <- update_children(g_hex$copy(), fill="white", stroke="white")$update(id="hex2")


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define document, add all service elements to 'defs'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
doc <- svg_doc(width=800, height=600)
doc$add('defs',pat, pat_lines, header_mask1, header_mask2, g1_hex, g1_ohex_right, 
        g1_ohex_uright, g1_ohex_left, g1_ohex_uleft, g2_hex)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 2 rectangles filled with patterns and masks - towers, one rectangle for stripes.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
doc$add('rect', x=35, y=220, width=max_xs*3, height=4.5*(max_ys+len), 
        fill=pat, mask="url(#header_mask1)")
doc$add('rect', x=310, y=0, width=350, height="100%", fill=pat_lines, stroke=colrs[1], stroke_width=3)
doc$add('rect', x=381, y=100, width=max_xs*3, height=4.5*(max_ys+len), 
        fill=pat, mask="url(#header_mask2)")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Place windows where they need to be
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
doc$use(`xlink:href`="#hex2", svg_prop$transform$translate(x=105, 300))
doc$use(`xlink:href`="#hex2", svg_prop$transform$translate(x=451, 180))

```

<!-- Raw HTML output. hidden by default -->
<details closed>
<summary> <span title='Raw HTML'> Raw SVG Text (click to open) </span> </summary>
```{r echo = FALSE, comment=""}
print(doc)
```
</details><br />


```{r echo = FALSE}
#doc
doc$save("svg/crystalcastles5155.svg")
rsvg::rsvg_png("svg/crystalcastles5155.svg", "images/crystalcastles5155.png")
knitr::include_graphics("images/crystalcastles5155.png")
```
Please, note that if some of the elements do not get properly rendered by your browser, try convering `svg` images to `png` using `rsvg::rsvg_png()` or rendering them in Chrome.
